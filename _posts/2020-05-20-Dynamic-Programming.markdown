---
layout: post
title: "DP-Dynamic Programming"
date: 2020-05-12 14:14:14 +0800
categories: algorithm
tag: [algorithm, programming]
---

# {{page.title}}

DP 动态规划是通过局部最优解来最终获取整体最优解的方法。
定义：Dynamic Programming 动态规划是指通过将一个复杂问题分解成一组简单子问题并对每个子问题进行一次求解并存储其结果，理想状态是存储在基于内存的存储结构中，最终解决复杂问题本身的一种解决问题的方法。
DP 分为自顶向下和自底向上两种解决方案。
DP 跟递归（Recursion）算法的关系密切，可以说是对递归算法的优化解法，降低了通过递归算法带来的额外数据空间的开销以及时间开销。因此，如果要掌握 DP，就首先要对递归算法有清楚的了解和掌握。

头递归与尾递归: 先递归，再运算称为头递归，反之为尾递归。

子结构优化 Optimal Substructure --- 贪心算法

重复子问题 Overlapping Subproblems

中间结果的记忆存储 Memoization --- 自顶向下的 DP

```
维基百科是这样描述的：

memoization最初是用来优化计算机程序使之计算的更快的技术，是通过存储调用函数的结果并且在同样参数传进来的时候返回结果。大部分应该是在递归函数中使用。

memoization这个词是在1968年被Donald Michie创造出来的，它源于拉丁语memoradum，在英语中通常简写为memo，因此就有了将一个函数的返回结果暂存入某个变量中的意思。（翻译水平略渣，如有不对，欢迎指正拍砖）。
```

Memoization = 递归调用 + 中间结果缓存 - 重复子问题计算

自底向上的 DP 的短板：为了解决主问题，需要计算全部子问题，因而会带来效率上的损失，甚至有的时候会造成性能低于递归算法。
如杨辉三角的解法：
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1

DP 的适用范围：可以进行字结构优化以及有重复子问题的都可以用 DP 的方式来解决

1. 是否可以将问题分解成同类型的子问题？ 如果是则可以首先通过递归算法求出一般解
2. 子问题是否有重叠？如果是则可以通过 Cache 进行空间换时间，提升效率
3. 是否需要进行优化，最大化或最小化或者需要统计可能的各种情况？

DP 的解题思路:

1. 检查是否可用 DP 解决。即是否满足上面 1.2.两点。
2. 定义递归。有同结构的子问题即意味着可以用递归来解决。
   1） 用子问题重新定义问题：自顶向下定义，此时不用考虑时间复杂度。
   2） 解决最基本的情况，其他交给递归。子问题通过递归来解决，剩下的就是基本情况（case）
   3） 添加终结条件。该步骤相对不太重要。
3. 试着引入 Memo(可选步骤)：如果某个子问题被调用了多次，那么就应该将其结果缓存，再次调用的时候就返回缓存。
4. 试着自底向上解决问题。这是我们试着消除递归并且重新定义并优化我们的最初解决方案的步骤，并且只存储后续步骤需要的中间结果。
